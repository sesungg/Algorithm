# 삽입 정렬(Insertion Sort)

비교 기반의 정렬 알고리즘으로, 정렬이 필요한 리스트를 이미 정렬된 부분과 정렬되지 않은 부분으로 나누어,
정렬되지 않은 부분의 요소를 하나씩 꺼내어 적절한 위치에 삽입함으로써 정렬을 완성하는 방식이다.
이 알고리즘은 단순하고 구현하기 쉽지만, 데이터가 많을 경우 성능이 떨어진다.

## 삽입 정렬의 작동 방식
1. 첫 번째 요소는 이미 정렬된 것으로 간주한다.
2. 두 번째 요소부터 시작하여, 각 요소를 정렬된 부분의 적절한 위치에 삽입한다.
3. 이 과정을 리스트의 끝까지 반복한다.

## 삽입 정렬의 단계별 예제
예를 들어, 다음과 같은 리스트가 주어졌다고 가정한다.
```json
[5, 2, 4, 6, 1, 3]
```

1. 첫 번째 요소:
   - 5는 이미 정렬된 상태로 간주한다.
2. 두 번째 요소:
   - 2를 정렬된 부분(5)과 비교한다.
   - 2가 5보다 작으므로 5 앞에 삽입한다.
   ```json
    [2, 5, 4, 6, 1, 3]
    ```
3. 세 번째 요소:
    - 4를 정렬된 부분(2, 5)과 비교한다.
    - 4는 5보다 작지만 2보다 크므로 2와 5 사이에 삽입한다.
   ```json
    [2, 4, 5, 6, 1, 3]
    ```
4. 네 번째 요소:
    - 6을 정렬된 부분(2, 4, 5)과 비교한다.
    - 6은 가장 큰 수이므로 5 뒤에 그대로 둔다.
   ```json
    [2, 4, 5, 6, 1, 3]
    ```
5. 다섯 번째 요소:
    - 1을 정렬된 부분(2, 4, 5, 6)과 비교한다.
    - 1이 가장 작으므로 2 앞에 삽입한다.
   ```json
    [1, 2, 4, 5, 6, 3]
    ```
6. 여섯 번째 요소:
    - 3을 정렬된 부분(1, 2, 4, 5, 6)과 비교한다.
    - 3은 4보다 작고 2보다 크므로 2와 4 사이에 삽입한다.
   ```json
    [1, 2, 3, 4, 5, 6]
    ```
   
## 삽입 정렬의 시간 복잡도
삽입 정렬은 최선의 경우(리스트가 이미 정렬된 경우) O(n)의 시간 복잡도를 가지지만,
최악의 경우(리스트가 역순으로 정렬된 경우) O(n²)의 시간 복잡도를 가집니다. 평균적인 경우도 O(n²)이다.

## 삽입 정렬의 공간 복잡도
삽입 정렬은 추가적인 메모리를 거의 사용하지 않으므로 공간 복잡도는 O(1)이다.
이는 정렬을 수행하는데 리스트 외의 추가 공간이 거의 필요하지 않음을 의미한다.

## 삽입 정렬의 장점과 단점

### 장점 :
   - 구현이 간단하고 직관직이다.
   - 데이터가 거의 정렬된 상태에서는 매우 효율적이다.
   - 작은 데이터셋에 대해서는 효율적이다.
### 단점 :
   - 시간 복잡도가 O(n²)로, 데이터의 개수가 많을수록 성능이 떨어진다.
   - 다른 효율적인 정렬 알고리즘에 비해 실무에서 잘 사용되지 않는다.
