# Bubble Sort

버블정렬은 비교 기반의 단순한 정렬 알고리즘 중 하나로, 인접한 두 요소를 반복적으로 비교하여 필요에 따라 교환하며 리스트를 정렬한다.
이 알고리즘은 단순하지만 효율성이 떨어지기 때문에 작은 데이터셋이나 학습 목적으로 주로 사용한다.

## 버블 정렬 알고리즘의 동작 방식
1. 리스트의 처음부터 시작하여 인접한 두 요소를 비교한다.
2. 앞의 요소가 뒤의 요소보다 크다면 두 요소의 위치를 교환한다.
3. 리스트의 끝까지 이 과정을 반복한다. 한 번의 반복이 끝나면 가장 큰 요소가 리스트의 마지막으로 이동하게 된다.
4. 리스트의 끝에 이미 정렬된 요소를 제외하고, 나머지 요소에 대해 위 과정을 반복한다.
5. 리스트가 정렬될 때까지 이 과정을 계속한다.

## 버블 정렬의 단계별 예제
예를 들어, 다음과 같은 리스트가 주어졌다고 가정한다.
```json
[5, 1, 4, 2, 8]
```
1. 첫 번째 패스 :
   - 5와 1을 비교하고 교환: [1, 5, 4, 2, 8]
   - 5와 4를 비교하고 교환: [1, 4, 5, 2, 8]
   - 5와 2를 비교하고 교환: [1, 4, 2, 5, 8]
   - 5와 8을 비교하고 교환 없음: [1, 4, 2, 5, 8]
   - 첫 번째 패스 후 가장 큰 요소 8이 마지막에 위치한다.
2. 두 번째 패스 :
   - 1과 4를 비교하고 교환 없음: [1, 4, 2, 5, 8]
   - 4와 2를 비교하고 교환: [1, 2, 4, 5, 8]
   - 4와 5를 비교하고 교환 없음: [1, 2, 4, 5, 8]
   - 두 번째 패스 후 두 번째로 큰 요소 5가 마지막에서 두 번째에 위치한다.
3. 세 번째 패스 :
   - 1과 2를 비교하고 교환 없음: [1, 2, 4, 5, 8]
   - 2와 4를 비교하고 교환 없음: [1, 2, 4, 5, 8]
   - 세 번째 패스 후 세 번째로 큰 요소 4가 마지막에서 세 번째에 위치한다.
4. 네 번째 패스 :
   - 1과 2를 비교하고 교환 없음: [1, 2, 4, 5, 8]
   - 네 번째 패스 후 네 번째로 큰 요소 2가 마지막에서 네 번째에 위치한다.
5. 다섯 번째 패스 :
   - 리스트는 이미 정렬되어 있으므로 종료한다.

## 시간 복잡도
- 최악의 경우 시간 복잡도 : O(n²) (리스트가 역순으로 정렬된 경우)
- 최선의 경우 시간 복잡도 : O(n) (리스트가 이미 정렬된 경우)
- 평균 시간 복잡도 : O(n²)

## 버블 정렬의 공간 복잡도
버블 정렬은 추가적인 메모리를 거의 사용하지 않으므로 공간 복잡도는 O(1)이다.
이는 정렬을 수행하는 데 리스트 외의 추가 공간이 거의 필요하지 않음을 의미한다.

## 장점과 단점

### 장점 :
- 구현이 간단하고 직관적이다.
- 데이터가 거의 정렬된 상태에서는 효율적이다.

### 단점 :
- 시간 복잡도가 O(n²)로, 데이터의 개수가 많을수록 성능이 떨어진다.
- 다른 효율적인 정렬 알고리즘에 비해 실무에서 잘 사용되지 않는다.