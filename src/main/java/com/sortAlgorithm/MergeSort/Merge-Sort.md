# 합병 정렬(Merge Sort)

합병 정렬(Merge Sort)은 분할 정복(Divide and Conquer) 알고리즘을 사용한 효율적인 정렬 알고리즘이다.
합병 정렬은 리스트를 두 개의 하위 리스트로 분할하고, 각 하위 리스트를 재귀적으로 정렬한 다음, 
정렬된 하위 리스트들을 병합하여 전체 리스트를 정렬한다.
합병 정렬은 안정 정렬로, 동인한 값의 요소들이 정렬 후에도 원래의 순서를 유지한다.

## 합병 정렬의 작동 방식
합병 정렬은 다음과 같은 단계로 작동한다.

1. 분할(Divide)
   - 리스트를 절반으로 나누어 두 개의 하위 리스트로 분할한다.
2. 정복(Conquer)
   - 각 하위 리스트를 재귀적으로 정렬한다.
3. 병합(Merge)
   - 두 개의 정렬된 하위 리스트를 하나의 정렬된 리스트로 병합한다.

## 합병 정렬의 단계별 예제
예를 들어, 다음과 같은 리스트가 주어졌다고 가정한다.
```json
[38, 27, 43, 3, 9, 82, 10]
```
1. 분할 단계 : 
   - 리스트를 절반으로 나누어 두 개의 하위 리스트로 분할한다.
   ```json
    [38, 27, 43, 3] [9, 82, 10]
    ```
   - 각 하위 리스트를 다시 분할한다.
   ```json
    [38, 27] [43, 3] [9, 82] [10]
    ```
   - 분할을 계속한다.
   ```json
    [38][27] [43][3] [8][82] [10]
    ```
2. 정복 단계
   - 각 하위 리스트를 정렬한다.
   ```json
    [27, 38] [3, 43] [9, 82] [10]
    ```
3. 병합 단게
   - 정렬된 하위 리스트들을 병합한다.
   ```json
    [27, 38] [3, 43] -> [3, 27, 38, 43]
    [9, 82] [10] -> [9, 10, 82]
    ```
   - 최종적으로 두 개의 정렬된 리스트를 병합한다.
   ```json
    [3, 27, 38, 43] [9, 10, 82] -> [3, 9, 10, 27, 38, 43, 82]
    ```
   
## 합병 정렬의 시간 복잡도
합병 정렬의 시간 복잡도는 항상 O(n log n)이다. 이는 리스트를 반으로 나누는 작업이 log n번 수행되고, 
각 단계에서 n개의 요소를 병합하는 작업이 수행되기 때문이다.
## 합병 정렬의 공간 복잡도
합병 정렬은 추가적인 메모리 공간을 필요로 한다.
이는 병합 작업을 수행하기 위해 리스트의 크기와 동일한 추가 공간이 필요하기 때문이다.
따라서 공간 복잡도는 O(n)이다.
## 합병 정렬의 장점과 단점
### 장점:
- 안정 정렬로, 동일한 값의 요소들이 정렬 후에도 원래의 순서를 유지한다.
- 항상 O(n log n)의 시간 복잡도를 가지며, 최악의 경우에도 성능이 일정하다.
- 큰 데이터를 처리하는 데 적합하다.
### 단점:
- 추가적인 메모리 공간이 필요하여, 공간 복잡도가 O(n)이다.
- 데이터가 많은 경우, 메모리 사용량이 커질 수 있다.