# 퀵 정렬(Quick Sort)
퀵 정렬은 분할 정복(Divide and Conquer) 알고리즘을 사용한 효율적인 정렬 알고리즘 중 하나이다.
평균적으로 O(n log n)의 시간 복잡도를 가지며, 대부분의 상황에서 매우 빠르게 작동합니다. 하지만 최악의 경우 O(n²)의 시간 복잡도를 가질 수 있다.

## 퀵 정렬의 작동 방식
퀵 정렬은 다음과 같은 단계로 작동한다.

1. 피벗 선택 (Choose a Pivot)
   - 리스트에서 하나의 요소를 피벗(pivot)으로 선택한다. 피벗을 선택하는 방법은 여러 가지가 있지만, 보통 리스트의 첫 번째 요소, 마지막 요소, 중간 요소 등을 사용한다.
2. 분할 (Partition)
   - 피벗을 기준으로 리스트를 두 개의 하위 리스트로 나눈다. 피벗보다 작은 요소들은 피벗의 왼쪽에, 피벗보다 큰 요소들은 피벗의 오른쪽에 배치한다.
3. 재귀적 정렬 (Recursive Sort)
   - 분할된 두 개의 하위 리스트에 대해 재귀적으로 퀵 정렬을 수행한다.

## 퀵 정렬의 단계별 예제
예를 들어, 다음과 같은 리스트가 주어졌다고 가정한다.
```json
[3, 6, 8, 10, 1, 2, 1]
```

1. 피벗 선택:
   - 리스트의 첫 번째 요소 3을 피벗으로 선택한다.
2. 분할:
   - 피벗을 기준으로 리스트를 분할한다.
   ```json
    왼쪽: [1, 2, 1]
    피벗: 3
    오른쪽: [6, 8, 10]
    ```
3. 재귀적 정렬:
   - 왼쪽 리스트와 오른쪽 리스트에 대해 재귀적으로 퀵 정렬을 수행한다.
   ```json
   왼쪽 리스트 [1, 2, 1]:
   - 피벗 1을 선택
   - 분할: 왼쪽 [], 피벗 1, 오른쪽 [2, 1]
   - 재귀적 정렬:
   - 왼쪽 [], 피벗 1, 오른쪽 [1, 2]
   - 정렬된 왼쪽 리스트: [1, 1, 2]

   오른쪽 리스트 [6, 8, 10]:
   - 피벗 6을 선택
   - 분할: 왼쪽 [], 피벗 6, 오른쪽 [8, 10]
   - 재귀적 정렬:
   - 왼쪽 [], 피벗 6, 오른쪽 [8, 10]
   - 정렬된 오른쪽 리스트: [6, 8, 10]

   ```
4. 병합:
   - 정렬된 왼쪽 리스트와 피벗, 정렬된 오른쪽 리스트를 병합하여 최종 정렬된 리스트를 얻는다.
   ```json
   [1, 1, 2, 3, 6, 8, 10]
   ```

## 퀵 정렬의 시간 복잡도
평균 시간 복잡도: O(n log n)
최악 시간 복잡도: O(n^2) (이미 정렬된 리스트에서 매번 최악의 피벗을 선택할 경우)
최선 시간 복잡도: O(n log n)
## 퀵 정렬의 공간 복잡도
퀵 정렬의 공간 복잡도는 O(log n)입니다. 이는 재귀 호출 스택의 깊이에 의해 결정됩니다.

## 퀵 정렬의 장점과 단점
### 장점:

평균적으로 매우 빠릅니다.
추가적인 메모리 사용이 적습니다 (제자리 정렬).
대부분의 실제 데이터에 대해 잘 동작합니다.
### 단점:

최악의 경우 시간 복잡도가 O(n^2)입니다.
안정 정렬이 아닙니다 (같은 값을 가진 요소들의 상대적인 순서가 유지되지 않을 수 있습니다).